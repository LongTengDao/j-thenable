{
	"version":
		3,
	"file":
		"j-thenable.min.js",
	"sourceRoot":
		"../../src/",
	"sources":
		["_.ts","await.ts","Thenable.ts","Thenable.prototype.ts","export.ts","version?text","resolve.ts","reject.ts","all.ts","race.ts","pend.ts"],
	"sourcesContent":
		[
			"import Promise_prototype from '.Promise.prototype?';\nimport undefined from '.undefined';\n\nexport type Executor = (resolve? :(value :any) => void, reject? :(error :any) => void) => void;\nexport type Onfulfilled = (value :any) => any;\nexport type Onrejected = (error :any) => any;\nexport type Status = 0 | 1 | 2;\nexport type Private = {\n\t_status :Status,\n\t_value :any,\n\t_dependents :Private[] | null,\n\t_onfulfilled :Onfulfilled | undefined,\n\t_onrejected :Onrejected | undefined,\n\t_Value :( () => any ) | undefined,\n\tthen (this :Private, onfulfilled? :Onfulfilled, onrejected? :Onrejected) :Private,\n};\n\nexport var PENDING :0 = 0;\nexport var FULFILLED :1 = 1;\nexport var REJECTED :2 = 2;\n\nexport var Private :{ new () :Private } = function Thenable () {} as any;\n\nvar wasPromise :boolean = false;\nexport function isThenableOnly (value :any) :value is Private {\n\treturn value instanceof Private;\n}\nexport var isThenable :(value :any) => value is Private = Promise_prototype\n\t? function () {\n\t\tvar Promise = function () {};\n\t\tPromise.prototype = Promise_prototype;\n\t\treturn function isThenable (value :any) :value is Private {\n\t\t\tif ( value instanceof Private ) { return true; }\n\t\t\twasPromise = value instanceof Promise;\n\t\t\treturn false;\n\t\t};\n\t}()\n\t: isThenableOnly;\nexport function beenPromise (value :any) :value is Readonly<Promise<any>> { return wasPromise; }\n\ntype PrependStack = { nextStack :PrependStack | null, thenable :Private, Value :() => any };\nvar prependStack :PrependStack | null = null;\nvar prepending :boolean = false;\nexport function prepend (thenable :Private) :void {\n\tvar callbackfn :( () => any ) | undefined = thenable._Value;\n\tif ( !callbackfn ) { return; }\n\tthenable._Value = undefined;\n\tif ( prepending ) {\n\t\tprependStack = { nextStack: prependStack, thenable: thenable, Value: callbackfn };\n\t\treturn;\n\t}\n\tprepending = true;\n\tfor ( ; ; ) {\n\t\ttry {\n\t\t\tvar value :any = callbackfn();\n\t\t\tif ( isThenable(value) ) {\n\t\t\t\tcallbackfn = value._Value;\n\t\t\t\tif ( callbackfn ) {\n\t\t\t\t\tvalue._Value = undefined;\n\t\t\t\t\tvalue._dependents!.push(thenable);\n\t\t\t\t\tprependStack = { nextStack: prependStack, thenable: value, Value: callbackfn };\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvar status :Status = value._status;\n\t\t\t\t\tif ( status===PENDING ) { value._dependents!.push(thenable); }\n\t\t\t\t\telse { flow(thenable, value._value, status); }\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( beenPromise(value) ) { depend(thenable, value); }\n\t\t\telse { flow(thenable, value, FULFILLED); }\n\t\t}\n\t\tcatch (error) { flow(thenable, error, REJECTED); }\n\t\tif ( !prependStack ) { break; }\n\t\tthenable = prependStack.thenable;\n\t\tcallbackfn = prependStack.Value;\n\t\tprependStack = prependStack.nextStack;\n\t}\n\tprepending = false;\n}\n\ntype FlowStack = { nextStack :FlowStack | null, thenable :Private, value :any, status :Status };\nvar flowStack :FlowStack | null = null;\nvar flowing :boolean = false;\nexport function flow (thenable :Private, value :any, status :Status) :void {\n\tif ( flowing ) {\n\t\tflowStack = { nextStack: flowStack, thenable: thenable, value: value, status: status };\n\t\treturn;\n\t}\n\tflowing = true;\n\tfor ( var _status :Status; ; ) {\n\t\tstack: {\n\t\t\tif ( status===FULFILLED ) {\n\t\t\t\tif ( thenable._onrejected ) { thenable._onrejected = undefined; }\n\t\t\t\tvar _onfulfilled :Onfulfilled | undefined = thenable._onfulfilled;\n\t\t\t\tif ( _onfulfilled ) {\n\t\t\t\t\tthenable._onfulfilled = undefined;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvalue = _onfulfilled(value);\n\t\t\t\t\t\tif ( isThenable(value) ) {\n\t\t\t\t\t\t\tprepend(value);\n\t\t\t\t\t\t\t_status = value._status;\n\t\t\t\t\t\t\tif ( _status===PENDING ) {\n\t\t\t\t\t\t\t\tvalue._dependents!.push(thenable);\n\t\t\t\t\t\t\t\tbreak stack;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tvalue = value._value;\n\t\t\t\t\t\t\t\tstatus = _status;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ( beenPromise(value) ) {\n\t\t\t\t\t\t\tdepend(thenable, value);\n\t\t\t\t\t\t\tbreak stack;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (error) {\n\t\t\t\t\t\tif ( thenable._status!==PENDING ) { break stack; }\n\t\t\t\t\t\tvalue = error;\n\t\t\t\t\t\tstatus = REJECTED;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( thenable._onfulfilled ) { thenable._onfulfilled = undefined; }\n\t\t\t\tvar _onrejected :Onrejected | undefined = thenable._onrejected;\n\t\t\t\tif ( _onrejected ) {\n\t\t\t\t\tthenable._onrejected = undefined;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvalue = _onrejected(value);\n\t\t\t\t\t\tif ( isThenable(value) ) {\n\t\t\t\t\t\t\tprepend(value);\n\t\t\t\t\t\t\t_status = value._status;\n\t\t\t\t\t\t\tif ( _status===PENDING ) {\n\t\t\t\t\t\t\t\tvalue._dependents!.push(thenable);\n\t\t\t\t\t\t\t\tbreak stack;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tvalue = value._value;\n\t\t\t\t\t\t\t\tstatus = _status;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ( beenPromise(value) ) {\n\t\t\t\t\t\t\tdepend(thenable, value);\n\t\t\t\t\t\t\tbreak stack;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse { status = FULFILLED; }\n\t\t\t\t\t}\n\t\t\t\t\tcatch (error) {\n\t\t\t\t\t\tif ( thenable._status!==PENDING ) { break stack; }\n\t\t\t\t\t\tvalue = error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthenable._value = value;\n\t\t\tthenable._status = status;\n\t\t\tvar _dependents :Private[] | null = thenable._dependents;\n\t\t\tif ( _dependents ) {\n\t\t\t\tthenable._dependents = null;\n\t\t\t\tfor ( var index :number = _dependents.length; index; ) {\n\t\t\t\t\tflowStack = { nextStack: flowStack, thenable: _dependents[--index], value: value, status: status };\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( !flowStack ) { break; }\n\t\tthenable = flowStack.thenable;\n\t\tvalue = flowStack.value;\n\t\tstatus = flowStack.status;\n\t\tflowStack = flowStack.nextStack;\n\t}\n\tflowing = false;\n}\n\nexport function depend (thenable :Private, value :Readonly<{ then (...args :any[]) :any }>) :void {\n\tvar red :boolean | undefined;\n\tvalue.then(\n\t\tfunction onfulfilled (value :any) :void {\n\t\t\tif ( red ) { return; }\n\t\t\tred = true;\n\t\t\tflow(thenable, value, FULFILLED);\n\t\t},\n\t\tfunction onrejected (error :any) :void {\n\t\t\tif ( red ) { return; }\n\t\t\tred = true;\n\t\t\tflow(thenable, error, REJECTED);\n\t\t}\n\t);\n}\n",
			"import { isThenableOnly, FULFILLED, REJECTED, prepend } from './_';\n\nexport default {\n\tawait: function (value :any) :any {\n\t\tif ( isThenableOnly(value) ) {\n\t\t\tprepend(value);\n\t\t\tswitch ( value._status ) {\n\t\t\t\tcase FULFILLED:\n\t\t\t\t\treturn value._value;\n\t\t\t\tcase REJECTED:\n\t\t\t\t\tthrow value._value;\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}\n}.await;\n",
			"import TypeError from '.TypeError';\n\nimport { PENDING, FULFILLED, REJECTED, Status, Private, isThenable, beenPromise, flow, depend, prepend, Executor, Onfulfilled, Onrejected } from './_';\n\nexport { Public as default };\n\ntype Public = Readonly<object & {\n\tthen (this :Public, onfulfilled? :Onfulfilled, onrejected? :Onrejected) :Public,\n}>;\n\nvar Public :{ new (executor :Executor) :Public } = function Thenable (this :Private, executor :Executor) :void {\n\tif ( typeof executor!=='function' ) { throw TypeError('Thenable executor is not a function'); }\n\tvar executed :boolean | undefined;\n\tvar red :boolean | undefined;\n\tvar _value :any;\n\tvar _status :Status | undefined;\n\tvar THIS :Private = this;\n\ttry {\n\t\texecutor(\n\t\t\tfunction resolve (value :any) {\n\t\t\t\tif ( red ) { return; }\n\t\t\t\tred = true;\n\t\t\t\tif ( executed ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif ( isThenable(value) ) {\n\t\t\t\t\t\t\tprepend(value);\n\t\t\t\t\t\t\t_status = value._status;\n\t\t\t\t\t\t\tif ( _status===PENDING ) { value._dependents!.push(THIS); }\n\t\t\t\t\t\t\telse { flow(THIS, value._value, _status!); }\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ( beenPromise(value) ) { depend(THIS, value); }\n\t\t\t\t\t\telse { flow(THIS, value, FULFILLED); }\n\t\t\t\t\t}\n\t\t\t\t\tcatch (error) { if ( THIS._status===PENDING ) { flow(THIS, error, REJECTED); } }\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t_value = value;\n\t\t\t\t\t_status = FULFILLED;\n\t\t\t\t}\n\t\t\t},\n\t\t\tfunction reject (error :any) {\n\t\t\t\tif ( red ) { return; }\n\t\t\t\tred = true;\n\t\t\t\tif ( executed ) { flow(THIS, error, REJECTED); }\n\t\t\t\telse {\n\t\t\t\t\t_value = error;\n\t\t\t\t\t_status = REJECTED;\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tif ( !red ) {\n\t\t\texecuted = true;\n\t\t\tTHIS._dependents = [];\n\t\t\treturn;\n\t\t}\n\t}\n\tcatch (error) {\n\t\tif ( !red ) {\n\t\t\tred = true;\n\t\t\tTHIS._value = error;\n\t\t\tTHIS._status = REJECTED;\n\t\t\treturn;\n\t\t}\n\t}\n\ttry { rEd(THIS, _status!, _value); }\n\tcatch (error) {\n\t\tif ( THIS._status===PENDING ) {\n\t\t\tTHIS._value = error;\n\t\t\tTHIS._status = REJECTED;\n\t\t\tTHIS._dependents = null;\n\t\t}\n\t}\n} as any;\n\nfunction rEd (THIS :Private, status :Status, value :any) :void {\n\tif ( status===FULFILLED ) {\n\t\tif ( isThenable(value) ) {\n\t\t\tprepend(value);\n\t\t\tstatus = value._status;\n\t\t\tif ( status===PENDING ) {\n\t\t\t\tTHIS._dependents = [];\n\t\t\t\tvalue._dependents!.push(THIS);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tTHIS._value = value._value;\n\t\t\t\tTHIS._status = status;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif ( beenPromise(value) ) {\n\t\t\tTHIS._dependents = [];\n\t\t\tdepend(THIS, value);\n\t\t\treturn;\n\t\t}\n\t}\n\tTHIS._value = value;\n\tTHIS._status = status;\n}\n",
			"import TypeError from '.TypeError';\nimport undefined from '.undefined';\n\nimport { PENDING, REJECTED, FULFILLED, Private, isThenable, beenPromise, Status, depend, prepend, Onfulfilled, Onrejected } from './_';\n\nexport default {\n\t_status: PENDING,\n\t_value: undefined,\n\t_dependents: null,\n\t_onfulfilled: undefined,\n\t_onrejected: undefined,\n\t_Value: undefined,\n\tthen: function then (this :Private, onfulfilled? :Onfulfilled, onrejected? :Onrejected) :Private {\n\t\tvar THIS :Private = this;\n\t\tprepend(THIS);\n\t\tvar thenable :Private = new Private;\n\t\tswitch ( THIS._status ) {\n\t\t\tcase PENDING:\n\t\t\t\tthenable._dependents = [];\n\t\t\t\tthenable._onfulfilled = onfulfilled;\n\t\t\t\tthenable._onrejected = onrejected;\n\t\t\t\tTHIS._dependents!.push(thenable);\n\t\t\t\treturn thenable;\n\t\t\tcase FULFILLED:\n\t\t\t\tif ( typeof onfulfilled==='function' ) { onto(THIS, onfulfilled, thenable); }\n\t\t\t\telse {\n\t\t\t\t\tthenable._value = THIS._value;\n\t\t\t\t\tthenable._status = FULFILLED;\n\t\t\t\t}\n\t\t\t\treturn thenable;\n\t\t\tcase REJECTED:\n\t\t\t\tif ( typeof onrejected==='function' ) { onto(THIS, onrejected, thenable); }\n\t\t\t\telse {\n\t\t\t\t\tthenable._value = THIS._value;\n\t\t\t\t\tthenable._status = REJECTED;\n\t\t\t\t}\n\t\t\t\treturn thenable;\n\t\t}\n\t\tthrow TypeError('Method Thenable.prototype.then called on incompatible receiver');\n\t}\n};\n\nfunction onto (THIS :Private, on :(_ :any) => any, thenable :Private) {\n\ttry { onto_try(thenable, on(THIS._value)); }\n\tcatch (error) {\n\t\tif ( thenable._status===PENDING ) {\n\t\t\tthenable._value = error;\n\t\t\tthenable._status = REJECTED;\n\t\t}\n\t}\n}\n\nfunction onto_try (thenable :Private, value :any) :void {\n\tif ( isThenable(value) ) {\n\t\tprepend(value);\n\t\tvar status :Status = value._status;\n\t\tif ( status===PENDING ) {\n\t\t\tthenable._dependents = [];\n\t\t\tvalue._dependents!.push(thenable);\n\t\t}\n\t\telse {\n\t\t\tthenable._value = value._value;\n\t\t\tthenable._status = status;\n\t\t}\n\t}\n\telse if ( beenPromise(value) ) {\n\t\tthenable._dependents = [];\n\t\tdepend(thenable, value);\n\t}\n\telse {\n\t\tthenable._value = value;\n\t\tthenable._status = FULFILLED;\n\t}\n}\n",
			"import seal from '.Object.seal';\nimport freeze from '.Object.freeze';\n\nimport version from './version?text';\nexport { version };\n\nimport resolve from './resolve';\nimport reject from './reject';\nimport all from './all';\nimport race from './race';\nimport pend from './pend';\nimport AWAIT from './await';\nexport {\n\tresolve,\n\treject,\n\tall,\n\trace,\n\tpend,\n\tAWAIT as await,\n};\n\nimport { Private, Executor } from './_';\nimport Public from './Thenable';\nimport prototype from './Thenable.prototype';\nPublic.prototype = Private.prototype = seal ? /*#__PURE__*/ seal(prototype) : prototype;\n\nimport Default from '.default?=';\nexport default Default(Public, {\n\tversion: version,\n\tThenable: Public,\n\tresolve: resolve,\n\treject: reject,\n\tall: all,\n\trace: race,\n\tpend: pend,\n\tawait: AWAIT\n});\n\nvar Thenable :Readonly<{ new (executor :Executor) :Public }> = freeze ? /*#__PURE__*/ freeze(Public) : Public;\ntype Thenable = Public;\nexport { Thenable };\n",
			"export default '4.0.1';",
			"import { isThenable, beenPromise, depend, FULFILLED, REJECTED, PENDING, Private } from './_';\n\nexport default function resolve (value? :any) :Public {\n\tif ( isThenable(value) ) { return value; }\n\tvar THIS :Private = new Private;\n\tif ( beenPromise(value) ) {\n\t\tTHIS._dependents = [];\n\t\ttry_depend(THIS, value);\n\t}\n\telse {\n\t\tTHIS._value = value;\n\t\tTHIS._status = FULFILLED;\n\t}\n\treturn THIS;\n};\n\nfunction try_depend (THIS :Private, value :any) {\n\ttry { depend(THIS, value); }\n\tcatch (error) {\n\t\tif ( THIS._status===PENDING ) {\n\t\t\tTHIS._value = error;\n\t\t\tTHIS._status = REJECTED;\n\t\t}\n\t}\n}\n\nimport Public from './Thenable';",
			"import { REJECTED, Private } from './_';\n\nexport default function reject (error? :any) :Public {\n\tvar THIS :Private = new Private;\n\tTHIS._status = REJECTED;\n\tTHIS._value = error;\n\treturn THIS;\n};\n\nimport Public from './Thenable';",
			"import undefined from '.undefined';\n\nimport { PENDING, REJECTED, FULFILLED, flow, prepend, isThenable, beenPromise, Status, Private, Onfulfilled } from './_';\n\nexport default function all (values :readonly any[]) :Public {\n\tvar THIS :Private = new Private;\n\ttry { all_try(values, THIS); }\n\tcatch (error) {\n\t\tif ( THIS._status===PENDING ) {\n\t\t\tTHIS._value = error;\n\t\t\tTHIS._status = REJECTED;\n\t\t\tTHIS._dependents = null;\n\t\t}\n\t}\n\treturn THIS;\n};\n\nfunction all_try (values :readonly any[], THIS :Private) :void {\n\tTHIS._dependents = [];\n\tfunction _onrejected (error :any) :any { THIS._status===PENDING && flow(THIS, error, REJECTED); }\n\tvar _value :any[] = [];\n\tvar count :number = 0;\n\tvar counted :boolean | undefined;\n\tfor ( var length :number = values.length, index :number = 0; index<length; ++index ) {\n\t\tvar value :any = values[index];\n\t\tif ( isThenable(value) ) {\n\t\t\tprepend(value);\n\t\t\tvar _status :Status = value._status;\n\t\t\tif ( _status===PENDING ) {\n\t\t\t\t++count;\n\t\t\t\t_value[index] = undefined;\n\t\t\t\tvalue._dependents!.push({\n\t\t\t\t\t_status: 0,\n\t\t\t\t\t_value: undefined,\n\t\t\t\t\t_dependents: null,\n\t\t\t\t\t_onfulfilled: function (index :number) :Onfulfilled {\n\t\t\t\t\t\treturn function (value :any) :void {\n\t\t\t\t\t\t\tif ( THIS._status===PENDING ) {\n\t\t\t\t\t\t\t\t_value[index] = value;\n\t\t\t\t\t\t\t\tif ( !--count && counted ) { flow(THIS, _value, FULFILLED); }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}(index),\n\t\t\t\t\t_onrejected: _onrejected\n\t\t\t\t} as Private);\n\t\t\t}\n\t\t\telse if ( _status===REJECTED ) {\n\t\t\t\tTHIS._value = value._value;\n\t\t\t\tTHIS._status = REJECTED;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse { _value[index] = value._value; }\n\t\t}\n\t\telse if ( beenPromise(value) ) {\n\t\t\t++count;\n\t\t\t_value[index] = undefined;\n\t\t\tvalue.then(\n\t\t\t\tfunction (index :number) :Onfulfilled {\n\t\t\t\t\tvar red :boolean | undefined;\n\t\t\t\t\treturn function (value :any) :void {\n\t\t\t\t\t\tif ( red ) { return; }\n\t\t\t\t\t\tred = true;\n\t\t\t\t\t\tif ( THIS._status===PENDING ) {\n\t\t\t\t\t\t\t_value[index] = value;\n\t\t\t\t\t\t\tif ( !--count && counted ) { flow(THIS, _value, FULFILLED); }\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}(index),\n\t\t\t\t_onrejected\n\t\t\t);\n\t\t}\n\t\telse { _value[index] = value; }\n\t}\n\tcounted = true;\n\tif ( !count && THIS._status===PENDING ) {\n\t\tTHIS._value = _value;\n\t\tTHIS._status = FULFILLED;\n\t\tTHIS._dependents = null;\n\t}\n}\n\nimport Public from './Thenable';",
			"import undefined from '.undefined';\n\nimport { flow, prepend, PENDING, FULFILLED, REJECTED, Status, isThenable, beenPromise, Private } from './_';\n\nexport default function race (values :readonly any[]) :Public {\n\tvar THIS :Private = new Private;\n\ttry { race_try(values, THIS); }\n\tcatch (error) {\n\t\tif ( THIS._status===PENDING ) {\n\t\t\tTHIS._value = error;\n\t\t\tTHIS._status = REJECTED;\n\t\t\tTHIS._dependents = null;\n\t\t}\n\t}\n\treturn THIS;\n};\n\nfunction race_try (values :readonly any[], THIS :Private) :void {\n\tTHIS._dependents = [];\n\tfunction _onfulfilled (value :any) :any { THIS._status===PENDING && flow(THIS, value, FULFILLED); }\n\tfunction _onrejected (error :any) :any { THIS._status===PENDING && flow(THIS, error, REJECTED); }\n\tvar that :Private = {\n\t\t_status: 0,\n\t\t_value: undefined,\n\t\t_dependents: null,\n\t\t_onfulfilled: _onfulfilled,\n\t\t_onrejected: _onrejected\n\t} as Private;\n\tfor ( var length :number = values.length, index :number = 0; index<length; ++index ) {\n\t\tvar value :any = values[index];\n\t\tif ( isThenable(value) ) {\n\t\t\tprepend(value);\n\t\t\tvar _status :Status = value._status;\n\t\t\tif ( _status===PENDING ) { value._dependents!.push(that); }\n\t\t\telse {\n\t\t\t\tTHIS._value = value._value;\n\t\t\t\tTHIS._status = _status;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if ( beenPromise(value) ) {\n\t\t\tvalue.then(_onfulfilled, _onrejected);\n\t\t\tif ( THIS._status!==PENDING ) { break; }\n\t\t}\n\t\telse {\n\t\t\tTHIS._value = value;\n\t\t\tTHIS._status = FULFILLED;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nimport Public from './Thenable';",
			"import { Private } from './_';\n\nexport default function pend (callbackfn :() => any) :Public {\n\tvar THIS :Private = new Private;\n\tTHIS._dependents = [];\n\tTHIS._Value = callbackfn;\n\treturn THIS;\n};\n\nimport Public from './Thenable';"
		],
	"names":
		["PENDING","FULFILLED","REJECTED","Private","wasPromise","isThenableOnly","value","Promise","isThenable","Promise_prototype","prototype","beenPromise","prependStack","prepending","prepend","thenable","callbackfn","_Value","undefined","nextStack","Value","_dependents","push","status","_status","flow","_value","depend","error","flowStack","flowing","stack","_onrejected","_onfulfilled","index","length","red","then","AWAIT","Public","executor","TypeError","executed","THIS","this","rEd","onfulfilled","onrejected","onto","on","onto_try","seal","Default","version","Thenable","resolve","try_depend","reject","all","values","all_try","counted","count","race","race_try","that","pend","await"],
	"mappings":
		"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"
}